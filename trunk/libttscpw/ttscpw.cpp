/*libttscpw - TTSCP Protocol Wrapper Copyright (C) 20007  Pavel Slechta (slechta@email.cz)This program is free software: you can redistribute it and/or modifyit under the terms of the GNU General Public License as published bythe Free Software Foundation, either version 3 of the License, or(at your option) any later version.This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU General Public License for more details.You should have received a copy of the GNU General Public Licensealong with this program.  If not, see <http://www.gnu.org/licenses/>.*/#include "ttscpw.h"#ifdef WIN32#include "rawaudio.h"#endif#ifdef _UNIX_#include "oss.h"#endifint TTSCPW::init(char *HOST, int PORT, char *STREAM, int TIMEOUT){int e;#ifdef _UNIX_ossd.audiofd = 0; //Very important - thread syncossd.wavelen = 0;#endif//*****Set parametersif(strlen(HOST) >= sizeof(host)) { 	printf("TTSCPW::TTSCPW:Buffer overflow attempt: HOST too long");	return -6;}else strcpy(host, HOST);if(strlen(STREAM) >= sizeof(stream)) { 	printf("TTSCPW::TTSCPW:Buffer overflow attempt: STREAM too long");	return -7;}else strcpy(stream, STREAM);port = PORT;utimeout = TIMEOUT; // 0,1 seconds//********End of setParametrs//WINDOWS BLOB***********#ifdef WINSOCKint iResult = WSAStartup(MAKEWORD(2,2), &wsaData);if (iResult != 0) {    printf("WSAStartup failed: %d\n", iResult);    return -5; //Indicate an extra error for WinSock only :):):)}#endif//*****************END OF WINDOWS BLOBmemset(hCtrl,'\0', 30);memset(hData,'\0', 30);//Ctrl initsockCtrl = createConnection();if (sockCtrl <= 0) {	printf("TTSCPW::TTSCPW:Cannot create ctrl socket\n");	return -1;}e = getHandle(sockCtrl, hCtrl);if (e < 0 ){	printf("TTSCPW::TTSCPW:%d:Cannot get ctrl handle\n", e);	return -2;}//Data initsockData = createConnection();if (sockData <= 0) {	printf("TTSCPW::TTSCPW:Cannot create data socket\n");	return -3;}e = getHandle(sockData, hData);if (e < 0 ){	printf("TTSCPW::TTSCPW:%d:Cannot get data handle\n", e);	return -4;}printf("HANDLES ARE:\nhCtrl:%s\nhData:%s\n******\n",hCtrl, hData);if(createDataChannel()) return -8;if(setStream(TTSCPW_LOCALSOUND)) return -9;//Asi bych to mel resit az potom//sflush(sockCtrl); // to be sure//sflush(sockData); // to be surereturn 0;}int *TTSCPW::ipstrlen(char *buf){char clen[15];int *len = (int *)malloc(sizeof(int));sprintf(clen, "%d", strlen(buf));*len = atoi(clen);return len;}int TTSCPW::istrlen(char *buf){char clen[15];int len;sprintf(clen, "%d", strlen(buf));return atoi(clen);}int TTSCPW::waitForLine(int s, char *line, int len, int usec){    fd_set fds;    int n;    char *b = (char *) malloc(sizeof(char)); //Delakokvat    struct timeval tv;    memset(line,'\0',len);//MUSI BYT kvuli strcat    // set up the file descriptor set    FD_ZERO(&fds);//     if (recv(s, b, 1, MSG_PEEK)<= 0) //blokuje//     { // 	     free(b);// 	     perror("TTSCPW:waitForLine: socket neni v poradku\n");// 	     return -4; //     }           FD_SET(s, &fds); //Udela velmi mile rado SIGSEGV, kdyz socket s neni pripojeny    // set up the struct timeval for the timeout    tv.tv_sec = (usec - (usec % 1000000)) / 1000000;    tv.tv_usec = usec % 1000000;		int probl;    	for (int bytesRecv = 0; bytesRecv < len - 1 ; bytesRecv++) //Buffer overflow check (beacuse of strncat), -1 is for \0 purposes	{    		// wait until timeout or data received		select_restart:    		n = select(s+1, &fds, NULL, NULL, &tv);    		if (errno == EINTR) 		{        		// some signal just interrupted us, so restart			perror("RESTART:select interrupted by a signal\n");        		goto select_restart;    		}	    	if (n == 0) 		{			free(b);			return -2; // timeout!		}    		if (n == -1) 		{		  printf("TTSCPW:waitForLine: select error\n", n);			free(b);					return -1; // error		}				probl = recv(s, b, 1, 0);		if (probl <= 0) 		{			printf("TTSCPW:waitForLine: Problem s recv cislo:%d\n", probl);			free(b);			return -3;		}				if( memchr(b,'\n',strlen(b)) != NULL ) //LF found		{						//strcat(line, "\0");			//memset(line + bytesRecv + 1, 0x00, 1); //To +1 je divny, ja cekal -1			free(b);			return 0; //OK, line returned in *line		} 		if( memchr(b,'\r',strlen(b)) == NULL ) //Kdyz b==CR		{ 		strncat(line, b, 1); //strncat - be carefull with buffer overflow		}		else bytesRecv--; // Protoze nic nezapiseme do line, protoze tam nechceme CR (LF se resi jinde)					}	perror("TTSCPW:waitForLine: BuuffOverflowAttempt - too much characters in one line\n");	free(b);	return -5; //Buffer overflow Attempt}int TTSCPW::sendall(int s, char *buf, int *len){    int total = 0;        // how many bytes we've sent    int bytesleft = *len; // how many we have left to send    int n;    while(total < *len) {        n = send(s, buf+total, bytesleft, 0);        if (n == -1) { break; }        total += n;        bytesleft -= n;    }    *len = total; // return number actually sent here    return n==-1?-1:0; // return -1 on failure, 0 on success} int TTSCPW::sendq(int sock, char *text){int *len = ipstrlen(text);int n = sendall(sock, text, len);free(len);return n;}int TTSCPW::createSocket(){	int sockfd = socket(PF_INET, SOCK_STREAM, 0);	if(sockfd == 0) printf("cannot create socket\n");	return sockfd;	}int TTSCPW::createConnection(){		int sockfd = createSocket();	struct sockaddr_in serv_addr;	struct hostent *server;	server = gethostbyname(host);			memset((char *) &serv_addr, '\0', sizeof(serv_addr)); //Vynuluj serv_addr			server = gethostbyname(host);		if (server == NULL) {		fprintf(stderr,"ERROR, no such host\n");		return -1;	}		serv_addr.sin_family = AF_INET;	//bcopy((char *)server->h_addr, (char *)&serv_addr.sin_addr.s_addr, server->h_length); //IP	memmove((char *)&serv_addr.sin_addr.s_addr , (char *)server->h_addr, server->h_length); //to pretypovani se mi nelibi  serv_addr.sin_port = htons(port); //Port		//To pretypovani (const sockaddr*) se mi ale vubec nelibi	//A taky nevim jestli je tu nejaky timeout nebo to neblokuje, :Â°)?	if (connect(sockfd, (const sockaddr*)&serv_addr, sizeof(serv_addr)) < 0)	{		printf("ERROR connecting");		return -1; //Indicate error	}	return sockfd;}int TTSCPW::createDataChannel(){char writebuf[50];char readbuf[100]; memset(writebuf,'\0', 50);memset(readbuf,'\0', 100);sprintf(writebuf, "data %s\n", hCtrl); //Jenom bacha na \0 na konci cele stringui na konci hCtrl!!!if (sendq(sockData, writebuf))printf("data hctrl error1\n"); //Jenom bacha na \0 na konci cele stringui na konci hCtrl!!!int n = waitForLine(sockData, readbuf, sizeof(readbuf), utimeout); // 1 second timeoutif (n) //Some error occured{	printf("Data hctrl FAILED\n");	return -1;}if (!strcmp(readbuf, "200")){	printf("data hctrl FAILED\n");	return -1;}printf("Data hctrl response:%s\n", readbuf);return 0;}//Of createDataChannelint TTSCPW::getHandle (int sockfd, char *handle){int n;char line[1024];	for(int numLines = 1;;numLines++){	n = waitForLine(sockfd, line, sizeof(line), utimeout); // 1 second timeout	if (n != 0) //Some error occured	{    		printf("getHandle:%d:Prusvih!(ala waitForLine)\n", n);		return -1;	}	printf("LINE#%d:%s\n", numLines, line);		if (numLines == 1 && strcmp(line, "TTSCP spoken here") != 0)	{		printf("Not TTSCP protocol:LINEis:%s******\n", line);		return -2;	}						if (numLines > 100)	{		printf ("Too much lines\n");		return -3;	}			//Get handle		if (strstr(line, "handle:") != NULL )	{			printf("hline:%s\n", line);		if (strlen(line) <= 30)		{		memcpy(handle, strstr(line, "handle: ") + 8, 16); //Assuming line handle: 16chars!!!!!!		return 0;		}		else		{		printf("Cannot get handle\n");		}	}} //End of for	getchar();	return -1;} //End of getHandle()int recvtimeout(int s, char *buf, int len, int usec){    fd_set fds;    int n;    struct timeval tv;    // set up the file descriptor set    FD_ZERO(&fds);    FD_SET(s, &fds); //kdyz neni s ok tak SIGSEGV    // set up the struct timeval for the timeout    tv.tv_sec = (usec - (usec % 1000000)) / 1000000;    tv.tv_usec = usec % 1000000;    // wait until timeout or data receivedselect_restart:    n = select(s+1, &fds, NULL, NULL, &tv);    if (errno == EINTR) {      // some signal just interrupted us, so restart	    printf("RESTART\n");      goto select_restart;    }    if (n == 0) return -2; // timeout!    if (n == -1) return -1; // error    // data must be here, so do a normal recv()    return recv(s, buf, len, 0);}int TTSCPW::setl(char *param, char *value){char writebuf[100];if (8 + istrlen(param) + istrlen(value) > 98) return -1; //Buffer overflow checksprintf(writebuf, "setl %s %s\n", param, value);if (sendq(sockCtrl, writebuf)) return -1;return getResponse(writebuf, sizeof(writebuf));}int TTSCPW::setStream(int iMethod){char readbuf[50];char writebuf[100];memset(readbuf,'\0', 50);memset(writebuf,'\0', 100);if (6 + strlen(hData) + strlen(stream) > 98){	printf("ERROR - stream too long/buffer overflow attempt\n");	return -1;}if (iMethod == TTSCPW_LOCALSOUND) sprintf(writebuf, "strm $%s%s#localsound\n", hData, stream);else sprintf(writebuf, "strm $%s%s$%s\n", hData, stream, hData);//printf("writebuf:%s\n", writebuf);if (sendq(sockCtrl, writebuf)){	printf("Cannot establish stream!1\n");	return -1;}//int n = recvtimeout(sockCtrl, readbuf, sizeof(readbuf), 1); // 1 second timeoutint n = waitForLine(sockCtrl, readbuf, sizeof(readbuf) , utimeout);if (n) //Some error occured{	printf("strm failed\n");	return -1;}if (!strcmp(readbuf, "200")){	printf("Stream NOT established\n");	return -1;}return 0;}//Possilble problem with more direct say functions in isOK function, due to mishmashed responeses to 2 or more commands//Better do 1 function and just before calling the function, change streamint TTSCPW::say(char *text){if (strlen(text) < 1) return -1;//sflush(sockCtrl);char writebuf[100];sprintf(writebuf, "appl %d\n", strlen(text));sendq(sockCtrl, writebuf);sendq(sockData, text);//return isOK(9000000);//3 secondsreturn 0;}TTSCPW::~TTSCPW(){//sendq(sockCtrl, "\ndone\n");#ifdef WINSOCKclosesocket(sockCtrl);closesocket(sockData);WSACleanup();#endif#ifdef _UNIX_close(sockCtrl);close(sockData);#endif}int TTSCPW::setLanguage(char *language){return setl("language", language);}int TTSCPW::setVoice(char *voice){return setl("voice", voice);}int TTSCPW::stop(){char writebuf[100];sprintf(writebuf, "intr %s\n", hCtrl);return sendq(sockCtrl, writebuf);//char *text = "appl 0\n";//sendq(sockCtrl, text);}int TTSCPW::stopf(){sendq(sockCtrl, "appl 1\n");sendq(sockData, "\n");return 0;}int TTSCPW::setInit_f(int f){//Bacha na buffer overflow, ale jelikoz je val 20 tak by nemel nastat kvuli int, otazkou je jestli na jine platforme nebude//mit jinou velikostchar val[20];sprintf(val, "%d", f);return setl("init_f", val);}int TTSCPW::setInit_i(int i){//Bacha na buffer overflow, ale jelikoz je val 20 tak by nemel nastat kvuli int, otazkou je jestli na jine platforme nebude//mit jinou velikostchar val[20];sprintf(val, "%d", i);return setl("init_i", val);}int TTSCPW::setInit_t(int t){//Bacha na buffer overflow, ale jelikoz je val 20 tak by nemel nastat kvuli int, otazkou je jestli na jine platforme nebude//mit jinou velikostchar val[20];sprintf(val, "%d", t);return setl("init_t", val);}int TTSCPW::getl(char *param, char *buffer, int len){sflush(sockCtrl); //Dost dulezita vecif(sendq(sockCtrl, "show ")) return -1;if(sendq(sockCtrl, param)) return -1;if(sendq(sockCtrl, "\n")) return -1; //LFreturn getResponse(buffer, len);}int TTSCPW::getResponse(char *buffer, int len) //SuX a lot{int bytesWritten = 0;char line[1024];memset(line, '\0', len); //Kvuli strcatmemset(buffer, '\0', len); //Kvuli strcat//if (!buffer) return -10; //Invalid pointer  while(waitForLine(sockCtrl, line, sizeof(line), utimeout) >= 0)  {      bytesWritten += strlen(line)+1; //Wait for line to vraci bez \n tak ji musime pripocist protoze potom pridame \n      if (bytesWritten >= len-1) return -5; // -1 protoze \n\0 a musi tam byt => ,, bufferOverflow Attempt u *buffer      strcat(buffer, line);      strcat(buffer, "\x0A");      if (strstr(line, "200") != NULL ) return 0;   } }int TTSCPW::isspace(char c){   return c == ' '  || c == '\t' ||          c == '\v' || c == '\f'  ;  }char *TTSCPW::lTrim(char *p){    while (p && isspace(*p)) ++p ;    return p;}char *TTSCPW::rTrim(char *p){    char * temp;    if (!p) return p;    temp = (char *)(p + strlen(p)-1);    while ( (temp>=p) && isspace(*temp) ) --temp;    *(temp+1) = '\0';    return p;}char *TTSCPW::Trim(char *p){    return lTrim(rTrim(p));}//Flushes the socket - i dont know better way howto do it, keep in mind that socket in windows//is not treated as a file descrioptorint TTSCPW::sflush(int sock)  {  int n;  char buf[200];    while (1)  {  n = recvtimeout(sock, buf, sizeof(buf), 200000); //200ms  if (n == -2) return 0;  if (n <= 0) return -1;  }}int TTSCPW::isOK(int utimeout) //shadowed utimeout{int n;char line[1024];bool bOK = false;  do  {    n = waitForLine(sockCtrl, line, sizeof(line), utimeout);    //printf("getResponse, n is:%d\n",n);        if (n < 0 && n != -2) return n;    if (n != -2) if (strstr(line, "200") != NULL ) return 0; //Nebezpecny  } while (!n);  return -11;  }int TTSCPW::getInit_f(int *f){char buffer[20];if (!f) return -20; //Invalid pointerint n = getl("init_f", buffer, sizeof(buffer));*f = atoi(buffer);return n;}int TTSCPW::getInit_i(int *i){char buffer[20];if (!i) return -20; //Invalid pointerint n = getl("init_i", buffer, sizeof(buffer));*i = atoi(buffer);return n;}int TTSCPW::getInit_t(int *t){char buffer[20];if (!t) return -20; //Invalid pointerint n = getl("init_t", buffer, sizeof(buffer));*t = atoi(buffer);return n;}int TTSCPW::deinit(){#ifdef WINSOCKclosesocket(sockCtrl);closesocket(sockData);WSACleanup();#endif#ifdef _UNIX_close(sockCtrl);close(sockData);#endifreturn 0;}int TTSCPW::done(){sendq(sockCtrl, "\ndone\n");}int recvall(int s, char *buf, int len, int usec){    fd_set fds;    int n;    struct timeval tv;    char *b = (char *) malloc(sizeof(char)); //Delakokvat    int bytesWritten;        // set up the file descriptor set    FD_ZERO(&fds);    FD_SET(s, &fds); //kdyz neni s ok tak SIGSEGV    // set up the struct timeval for the timeout    tv.tv_sec = (usec - (usec % 1000000)) / 1000000;    tv.tv_usec = usec % 1000000;    for (bytesWritten = 0; bytesWritten < len; bytesWritten++)    {        // wait until timeout or data receivedselect_restart:        n = select(s+1, &fds, NULL, NULL, &tv);        if (errno == EINTR) {          // some signal just interrupted us, so restart            printf("RESTART\n");          goto select_restart;        }                if (errno == EBADF) {            printf("One of the descriptor sets specified an invalid descriptor.\n");        }                if (errno == EINVAL) {            printf("The specified time limit is invalid.  One of its com-ponents is negative or too large.\n");        }    #ifdef WINSOCK        switch(WSAGetLastError())        {        case WSANOTINITIALISED:            printf("A successful WSAStartup call must occur before using this function.\n");            break;        case WSAEFAULT:            printf("The Windows Sockets implementation was unable to allocate needed resources for its internal operations, or the readfds, writefds, exceptfds, or timeval parameters are not part of the user address space.\n");            break;        case WSAENETDOWN:            printf("The network subsystem has failed.\n");            break;        case WSAEINVAL:            printf("The time-out value is not valid, or all three descriptor parameters were null.\n");            break;            case WSAEINTR:            printf("A blocking Windows Socket 1.1 call was canceled through WSACancelBlockingCall.\n");            break;          case WSAEINPROGRESS:            printf("A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.\n");            break;        case WSAENOTSOCK:            printf("One of the descriptor sets contains an entry that is not a socket.\n");            break;          }#endif            if (n == 0)        {          free(b);          return -2; // timeout!        }        if (n == -1)        {          free(b);          return -1; // error        }            n = recv(s, b, 1, 0); // 1Byte                        if (n != 1)        {        //This code should never get executed, because of select        free(b);        printf("nnn:%d\n", n);        return -3;        }                memcpy(buf + bytesWritten, b, 1);        }    return bytesWritten;}int TTSCPW::sayw(char * text){int e;char writebuf[100];#ifdef WIN32sflush(sockCtrl);sflush(sockData);sprintf(writebuf, "appl %d\n", strlen(text));if(sendq(sockCtrl, writebuf)) printf("Cannot send appl in sayw\n");e = sendq(sockData, text); if(e) printf("Cannot send data in sayw e:%d\n", e);streamWav(sockData, utimeout);#endif#ifdef _UNIX_sflush(sockCtrl);printf("ossd.wavelen:%d\n", ossd.wavelen);if (ossd.audiofd != 0){//printf("fdAudio=%d\n", ossd.audiofd);pthread_cancel(threadOSS); //SIGSEGV when thread doesnt existshaltOSS(ossd.audiofd); //Asi jenom zbytecne zdrzuje, chce se mrknout do manualu, radsi!!!(close bude as hodne blokovat)close(ossd.audiofd); //freechar *flushbuf;flushbuf = (char *) malloc(ossd.wavelen);if  (ossd.wavelen > 0){    if (recvall(sockData, flushbuf, ossd.wavelen, 200000))    {        printf("sflush navic\n");        sflush(sockData);    }}free(flushbuf);}ossd.sockfd = sockData;sprintf(writebuf, "appl %d\n", strlen(text));if(sendq(sockCtrl, writebuf)) printf("Cannot send appl in sayw\n");e = sendq(sockData, text); if(e) printf("Cannot send data in sayw e:%d\n", e);printf("Creating POSIX thread...\n");if(pthread_create( &threadOSS, NULL, streamWavOSS, (void*) &ossd)){    perror("pthread_create() FAILED");    return 0;}#endif//for (int i = 0; i< sizeof(wf); i++) putc(wf + i);return 0;}int TTSCPW::setCharset(char *charset){return setl("charset", charset);} 